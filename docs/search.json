[
  {
    "objectID": "src/stockprice.html",
    "href": "src/stockprice.html",
    "title": "2  幾何ランダムウォーク／幾何ブラウン運動",
    "section": "",
    "text": "2.1 GARCH モデル\n株式価格の系列 \\(\\{S_t\\}_{t=0,1,2,...}\\) について、単純収益率 \\(\\tilde{r}_t\\) と対数収益率 \\(r_t\\) を以下のように定義する。\n\\[\n\\begin{aligned}\n\\tilde{r}_t &= \\frac{S_{t+1}}{S_t} - 1 \\\\\nr_t &= \\ln\\left(\\frac{S_{t+1}}{S_t}\\right)\n\\end{aligned}\n\\]\nここで、価格比（粗収益率）を \\(R = S_{t+1}/S_t\\) と置くと、\\(\\tilde{r}_t = R - 1\\)、\\(r_t = \\ln R\\) となる。\\(R \\approx 1\\) の近傍では \\(R-1 \\approx \\ln R\\) が成り立つため、実用上の範囲（数％程度の変動）では二つの収益率に大きな差はない。\n対数収益率の系列 \\(\\{r_t\\}_{t=0,1,2,...}\\) が与えられたとき、時点 \\(t\\) における価格 \\(x_t\\) は以下の和を計算することで導出できる。\n\\[\nS_{t+1}=S_{t}\\exp{(r_t)}=S_{t-1}\\exp(r_{t-1}+r_t)=\\dots=S_0\\exp(\\sum_{s=0}^t{r_s})\n\\]\nこの加法性により、対数収益率は計算効率が良く、統計的扱いも容易である。 以下では、対数収益率をいくつかの確率モデルで表現し、株式価格変動のシミュレーションを実行する。\nまず、対数収益率が毎期独立に正規分布 \\(N(0.001, 0.01^2)\\) に従うと仮定する。\n\\[\nr_t w\n\\]\nこのとき、累計の対数収益率はドリフト付きのランダムウォークであり、株式価格は幾何ランダムウォークであって、対数正規分布に従う。いわゆるブラック・ショールズ・モデルの離散化表現に相当する。価格過程のサンプルは以下のように計算・描画できる。\n金融時系列には、一度大きな変動があるとその後しばらくの間は大きな変動が続きやすいという傾向（ボラティリティ・クラスタリング）がある。 \\(\\text{GARCH}(p,q)\\) モデルは、このボラティリティの持続性をモデル化したものであり、収益率の分散 \\(\\sigma_t^2\\) を、過去の残差の二乗 \\(\\epsilon_{t-i}^2\\) と過去の分散 \\(\\sigma_{t-j}^2\\) を用いて以下のように定式化する。\n\\[\n\\sigma_t^2=\\omega+\\sum_{i=1}^q\\alpha_i\\epsilon_{t-i}^2+\\sum_{j=1}^p\\beta_j\\sigma_{t-j}^2\n\\]\nここでは、対数収益率の平均が定数 \\(0.1\\%\\)、分散が \\(\\text{GARCH}(1,1)\\) モデルに従うと仮定した場合の価格過程をシミュレーションする。\nlibrary(rugarch)\n\n# 時系列モデルの仕様定義\ngm_spec &lt;- ugarchspec(\n    variance.model = list(\n        model = \"sGARCH\",\n        garchOrder = c(1, 1)\n    ),\n    mean.model = list(\n        armaOrder = c(0, 0),\n        include.mean = TRUE\n    ),\n    distribution.model = \"norm\",\n    fixed.pars = list(\n        mu     = 0.001,\n        omega  = 0.000003,\n        alpha1 = 0.11,\n        beta1  = 0.88\n    )\n)\n\n# 対数収益率の生成\ngm_path &lt;- ugarchpath(\n    gm_spec,\n    n.sim = 1000,\n    m.sim = 1,\n    rseed = 0\n)\nr &lt;- fitted(gm_path)\n\n# 価格系列への変換\nprice &lt;- 100 * exp(cumsum(r))\n\n# 描画\nplot(r, type = \"l\", xlab = \"Time\", ylab = \"Return\")\nplot(price, type = \"l\", xlab = \"Time\", ylab = \"Price\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>幾何ランダムウォーク／幾何ブラウン運動</span>"
    ]
  },
  {
    "objectID": "src/stockprice.html#garch-モデル",
    "href": "src/stockprice.html#garch-モデル",
    "title": "2  株式価格変動のシミュレーション",
    "section": "2.2 GARCH モデル",
    "text": "2.2 GARCH モデル\n金融時系列には、一度大きな変動があるとその後しばらくの間は大きな変動が続きやすいという傾向（ボラティリティ・クラスタリング）がある。 \\(\\text{GARCH}(p,q)\\) モデルは、このボラティリティの持続性をモデル化したものであり、収益率の分散 \\(\\sigma_t^2\\) を、過去の残差の二乗 \\(\\epsilon_{t-i}^2\\) と過去の分散 \\(\\sigma_{t-j}^2\\) を用いて以下のように定式化する。\n\\[\n\\sigma_t^2=\\omega+\\sum_{i=1}^q\\alpha_i\\epsilon_{t-i}^2+\\sum_{j=1}^p\\beta_j\\sigma_{t-j}^2\n\\]\nここでは、対数収益率の平均が定数 \\(0.1\\%\\)、分散が \\(\\text{GARCH}(1,1)\\) モデルに従うと仮定した場合の価格過程をシミュレーションする。\n\nlibrary(rugarch)\n\n# 時系列モデルの仕様定義\ngm_spec &lt;- ugarchspec(\n    variance.model = list(\n        model = \"sGARCH\",\n        garchOrder = c(1, 1)\n    ),\n    mean.model = list(\n        armaOrder = c(0, 0),\n        include.mean = TRUE\n    ),\n    distribution.model = \"norm\",\n    fixed.pars = list(\n        mu     = 0.001,\n        omega  = 0.000003,\n        alpha1 = 0.11,\n        beta1  = 0.88\n    )\n)\n\n# 対数収益率の生成\ngm_path &lt;- ugarchpath(\n    gm_spec,\n    n.sim = 1000,\n    m.sim = 1,\n    rseed = 0\n)\nr &lt;- fitted(gm_path)\n\n# 価格系列への変換\nprice &lt;- 100 * exp(cumsum(r))\n\n# 描画\nplot(r, type = \"l\", xlab = \"Time\", ylab = \"Return\")\nplot(price, type = \"l\", xlab = \"Time\", ylab = \"Price\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>株式価格変動のシミュレーション</span>"
    ]
  },
  {
    "objectID": "src/stockprice.html#ブラックショールズモデル",
    "href": "src/stockprice.html#ブラックショールズモデル",
    "title": "2  幾何ランダムウォーク／幾何ブラウン運動",
    "section": "2.2 ブラック・ショールズ・モデル",
    "text": "2.2 ブラック・ショールズ・モデル",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>幾何ランダムウォーク／幾何ブラウン運動</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Finance-Notes: Time Series and SDE",
    "section": "",
    "text": "This repository explores time-series and SDE models for finance, with a focus on their relationships and implementation in both R and Python.\nこのリポジトリは、ファイナンスにおける時系列モデルと確率微分方程式（SDE）モデルの両方について、その関係に注目しながら整理することを目的とした（数学を得意としない著者による）個人的な学習ノートです。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>はじめに</span>"
    ]
  },
  {
    "objectID": "src/euler-maruyama.html",
    "href": "src/euler-maruyama.html",
    "title": "確率微分方程式の離散化",
    "section": "",
    "text": "以下の形式の伊藤過程を考える。\n\\[\nX_t = X_0 + \\int_0^t \\mu_s\\ ds + \\int_0^t \\sigma_s\\ dW_s\n\\]\nこれを微分形式で記述すると、以下の確率微分方程式（SDE）となる。\n\\[\ndX_t = \\mu_t\\ dt + \\sigma_t\\ dW_t\n\\]\n伊藤過程の見本路はどんな精度で拡大しても細かく振幅しているはずのものであり、そのまま描画することはできない。そこで、時間 \\([0, T]\\) を \\(N\\) 等分して離散化することを考える。時間の刻み幅は \\(\\Delta t\\) と表記する。\n\\[\n\\Delta t = T / N\n\\]\nオイラー・丸山法（Euler-Maruyama approximation）では、伊藤過程を以下のように近似する。 ここで、\\(\\{\\epsilon_t\\}_t\\) は標準正規分布 \\(N(0, 1)\\) に従う互いに独立な確率変数である。\n\\[\n\\hat{X}_{t+\\Delta t} = \\hat{X}_t + \\mu_t \\Delta t + \\sigma_t \\sqrt{\\Delta t} \\epsilon_t\n\\]\nこの近似は、ウィーナー過程の増分 \\(dW_t = W_{t+\\Delta t} - W_t\\) が正規分布 \\(N(0, \\Delta t)\\) に従うという性質に基づいている。この増分の分散は \\(\\Delta t\\) であるから、標準正規分布に乗じる係数を \\(\\sqrt{\\Delta t}\\) とすべき点に注意する。\nウィーナー過程 \\(W_t\\) 自体は、伊藤過程においてドリフト項 \\(\\mu_t = 0\\)、拡散項 \\(\\sigma_t = 1\\) とした最も基本的なケースである。この過程のオイラー・丸山法による離散近似は以下のように表現できる。\n\\[\n\\hat{W}_{t+\\Delta t} = \\hat{W}_t + \\sqrt{\\Delta t} \\epsilon_t\n\\]\nこの過程は時系列分析におけるランダムウォークにほかならない。\n以下では、ウィーナー過程を離散化することで得られたランダムウォークの見本路を作成してプロットする。\n\nRPython\n\n\n\nlibrary(ggplot2)\ntheme_set(theme_bw())\n\nset.seed(42)\n\nN &lt;- 252\ndt &lt;- 1 / N\ntime &lt;- seq(0, 1, by = dt)\n\n# 標準正規乱数の生成と累積和の計算\ndf &lt;- list()\nfor (i in 1:25) {\n  dW &lt;- sqrt(dt) * rnorm(N)\n  path &lt;- cumsum(c(0, dW))\n  df[[length(df) + 1]] &lt;-\n    data.frame(id = i, time=time, path=path)\n}\ndf &lt;- do.call(rbind, df)\n\n# プロット\nggplot(df) +\n  geom_line(aes(time, path, group=id)) +\n  labs(\n    title = \"Discretized Wiener Process\",\n    x = \"Time (t)\", y = \"W(t)\"\n  )\n\n\n\n\nウィーナー過程のシミュレーション（R）\n\n\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import *\ntheme_set(theme_bw())\n\nnp.random.seed(42)\n\nN = 252\ndt = 1 / N\ntime = np.linspace(0, 1, N + 1)\n\n# 標準正規乱数の生成と累積和の計算\ndf = list()\nfor i in range(25):\n  dW = np.sqrt(dt) * np.random.normal(0, 1, N)\n  path = np.cumsum(np.insert(dW, 0, 0))\n  df.append(\n    pd.DataFrame({'id':i, 'time':time, 'path':path})\n  )\ndf = pd.concat(df)\n\n# プロット\nggplot(df) + \\\n  geom_line(aes(\"time\", \"path\", group=\"id\")) + \\\n  labs(\n    subtitle = \"Discretized Wiener Process\",\n    x = \"Time (t)\", y = \"W(t)\"\n  )\n\n\n\n\nウィーナー過程のシミュレーション（Python）",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>確率微分方程式の離散化</span>"
    ]
  },
  {
    "objectID": "src/euler-maruyama.html#ウィーナー過程への適用",
    "href": "src/euler-maruyama.html#ウィーナー過程への適用",
    "title": "オイラー・丸山法",
    "section": "ウィーナー過程への適用",
    "text": "ウィーナー過程への適用\n特に、ウィーナー過程 \\(W_t\\) は、伊藤過程においてドリフト項 \\(\\mu_t = 0\\)、拡散項 \\(\\sigma_t = 1\\) とした最も基本的なケースである。その離散近似は以下のように表現できる。\n\\[\n\\hat{W}_{t+\\Delta t} = \\hat{W}_t + \\sqrt{\\Delta t} \\epsilon_t\n\\]\n\n実装例\n\nR\n\n\n\n# パラメータ設定\nT &lt;- 1\nN &lt;- 200\ndt &lt;- T / N\n\n# 乱数の生成と累積和\n# c(0, ...) で初期値 W_0 = 0 を追加\ndW &lt;- sqrt(dt) * rnorm(N)\nW &lt;- cumsum(c(0, dW))\n\n# 時間軸の作成\nt_seq &lt;- seq(0, T, by = dt)\n\n# プロット\n# midr::par.midr() # ユーザー定義関数があればここで使用\nplot(t_seq, W, type = \"l\", \n     main = \"Discretized Wiener Process (Euler-Maruyama)\",\n     xlab = \"Time (t)\", ylab = \"W(t)\",\n     col = \"blue\", lwd = 1.5)\ngrid()\n\n\n\n\n\n\n\nFigure 2.1: Rによるウィーナー過程のシミュレーション\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# パラメータ設定\nT = 1.0\nN = 200\ndt = T / N\n\n# 乱数の生成と累積和\n# np.insert で初期値 0 を先頭に挿入\ndW = np.sqrt(dt) * np.random.normal(0, 1, N)\nW = np.cumsum(np.insert(dW, 0, 0))\n\n# 時間軸の作成\nt_seq = np.linspace(0, T, N + 1)\n\n# プロット\nplt.figure(figsize=(7, 4))\nplt.plot(t_seq, W, label='Wiener Process', color='blue')\nplt.title(\"Discretized Wiener Process (Euler-Maruyama)\")\nplt.xlabel(\"Time (t)\")\nplt.ylabel(\"W(t)\")\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\nFigure 2.2: Pythonによるウィーナー過程のシミュレーション",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>確率微分方程式の離散化</span>"
    ]
  },
  {
    "objectID": "src/returns.html",
    "href": "src/returns.html",
    "title": "収益率",
    "section": "",
    "text": "価格系列 \\(\\{S_t\\}_{t=0,1,2,...}\\) について、単純収益率 \\(\\tilde{r}_t\\) と対数収益率 \\(r_t\\) を以下のように定義する。\n\\[\n\\begin{aligned}\n\\tilde{r}_t &= \\frac{S_{t+1}}{S_t} - 1 \\\\\nr_t &= \\ln\\left(\\frac{S_{t+1}}{S_t}\\right)\n\\end{aligned}\n\\]\nここで、価格比（粗収益率）を \\(R = S_{t+1}/S_t\\) と置くと、\\(\\tilde{r}_t = R - 1\\)、\\(r_t = \\ln R\\) となる。\\(R \\approx 1\\) の近傍では \\(R-1 \\approx \\ln R\\) が成り立つため、実用上の範囲（数％程度の変動）では二つの収益率に大きな差はない。\n\ncurve(log(x), 0.5, 1.5, xlab = \"Ratio (R)\", ylab = \"Return (r)\")\ncurve(identity(x) - 1, add = TRUE, lty = \"dashed\")\n\n\n\n\n\n\n\n\n対数収益率の系列 \\(\\{r_t\\}_{t=0,1,2,...}\\) が与えられたとき、時点 \\(t\\) における価格 \\(x_t\\) は以下の和を計算することで導出できる。\n\\[\nS_{t+1}=S_{t}\\exp{(r_t)}=S_{t-1}\\exp(r_{t-1}+r_t)=\\dots=S_0\\exp(\\sum_{s=0}^t{r_s})\n\\]\nこの加法性により、対数収益率は計算効率が良く、統計的扱いも容易である。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>収益率</span>"
    ]
  },
  {
    "objectID": "src/vasicek.html",
    "href": "src/vasicek.html",
    "title": "Vasicekモデル",
    "section": "",
    "text": "Vasicek モデルは、金利が長期的にみれば一定の水準 \\(\\theta\\) に引き戻されるという平均回帰性 (Mean Reversion) を取り入れた瞬間金利（Instantaneous Interest Rate）のモデルである。\n確率微分方程式は以下で与えられる。\n\\[\ndr_t = \\kappa\\;(\\theta - r_t)\\;dt + \\sigma\\;dW_t\n\\]\nただし、\\(\\kappa\\) は長期平均金利への平均回帰速度、\\(\\theta\\) は長期平均金利の水準、\\(\\sigma\\) はボラティリティ、 \\(dW_t\\) はウィーナー過程である。\nシミュレーションのために、オイラー・丸山法を用いて離散化すると以下のようになる。\n\\[\nr_{t+\\Delta t} = r_t + \\kappa\\;(\\theta - r_t)\\;\\Delta t + \\sigma\\;\\sqrt{\\Delta t}\\;\\epsilon_t\n\\]\nこれを以下のように整理すると、Vasicekモデルを離散化したものが1次の自己回帰モデル AR(1) に対応することがわかる。\n\\[\nr_{t+\\Delta t} = \\kappa\\theta\\Delta t + (1 - \\kappa\\Delta t)\\;r_t + \\sigma\\;\\sqrt{\\Delta t}\\;\\epsilon_t\n\\]\n以下は、初期金利を \\(r_0 = 1\\%\\)、ボラティリティを \\(\\sigma=2\\%\\)、長期平均金利を \\(\\theta=5\\%\\)、平均回帰速度を \\(\\kappa=0.5\\) に設定した場合のシミュレーション例である。時間の経過とともに瞬間短期金利が \\(5\\%\\) に近づいていく様子が確認できる。\n\nRPython\n\n\n\nlibrary(ggplot2)\ntheme_set(theme_bw())\n\nset.seed(42)\n\nyears &lt;- 10\nN &lt;- 100 * years\ndt &lt;- years / N\ntime &lt;- seq(0, years, by = dt)\n\nr0 &lt;- 0.01\nsigma &lt;- 0.02\ntheta &lt;- 0.05\nkappa &lt;- 0.5\nm &lt;- 25\n\n# オイラー・丸山法によるシミュレーション\nrt &lt;- rep(r0, m)\ndf &lt;- list()\ndf[[1]] &lt;- data.frame(id = 1:m, time=time[1], rate=rt)\nfor (i in seq_len(N)) {\n  drift &lt;- kappa * (theta - rt) * dt\n  diffusion &lt;- sigma * sqrt(dt) * rnorm(m)\n  rt &lt;- rt + drift + diffusion\n  df[[length(df) + 1]] &lt;-\n    data.frame(id = 1:m, time=time[1 + i], rate=rt)\n}\ndf &lt;- do.call(rbind, df)\n\n# プロット\nggplot(df) +\n  geom_hline(yintercept = theta, linetype = \"dashed\") +\n  geom_line(aes(time, rate, group=id)) +\n  labs(\n    title = \"Discretized Vasicek Model\",\n    x = \"Time (t)\", y = \"Rate (t)\"\n  )\n\n\n\n\nVasicek モデルの離散シミュレーション（R）\n\n\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import *\ntheme_set(theme_bw())\n\nnp.random.seed(42)\n\nyears = 10\nN = 100 * years\ndt = years / N\ntime = np.linspace(0, years, N + 1)\n\nr0 = 0.01\nsigma = 0.02\ntheta = 0.05\nkappa = 0.5\nm = 25\n\n# オイラー・丸山法によるシミュレーション\nrt = np.repeat(r0, m)\ndf = list()\ndf.append(pd.DataFrame({'id':range(m), 'time':time[0], 'rate':rt}))\n\nfor i in range(N):\n  drift = kappa * (theta - rt) * dt\n  diffusion = sigma * np.sqrt(dt) * np.random.normal(0, 1, m)\n  rt = rt + drift + diffusion\n  df.append(\n    pd.DataFrame({'id':range(m), 'time':time[1+i], 'rate':rt})\n  )\ndf = pd.concat(df)\n\n# プロット\nggplot(df) + \\\n  geom_hline(yintercept=theta, linetype=\"dashed\") + \\\n  geom_line(aes(\"time\", \"rate\", group=\"id\")) + \\\n  labs(\n    subtitle = \"Discretized Vasicek Model\",\n    x = \"Time (t)\", y = \"Rate (t)\"\n  )\n\n\n\n\nVasicek モデルの離散シミュレーション（Python）\n\n\n\n\n\n\n\nVasicek モデルにおいて、時点 \\(t\\) における残存期間 \\(s\\) の利回り \\(R(t, t+s)\\) は以下の式で与えられる。\n\\[\n\\begin{align}\nR(t, t+s) &= \\frac{A(s) - B(s)\\;r_t}{s}\\\\\nB(s) &= \\frac{1 - e^{-\\kappa s}}{\\kappa}\\\\\nA(s) &= (\\theta^* - \\frac{\\sigma^2}{2\\kappa^2})(B(s) - s) - \\frac{\\sigma^2}{4\\kappa}B(s)^2\n\\end{align}\n\\]\nここで、\\(\\theta^*\\) は リスク中立的な長期平均金利 と呼ばれる。これは現実の平均金利 \\(\\theta\\) に、投資家がリスクに対して要求する上乗せ報酬（リスクプレミアム）を加味したものである。\n\\[\n\\theta^* = \\theta - \\frac{\\sigma\\lambda}{\\kappa}\n\\]\n一般に市場のリスク価格 \\(\\lambda\\) は負の値をとることが多く、その場合 \\(\\theta^* &gt; \\theta\\) となる。これは、市場が「現実の平均的な予測」よりも、リスクを考慮して「高めの金利」をイールドカーブに織り込むことを意味する。\n\nlibrary(ggplot2)\n\nkappa  &lt;- 0.5\ntheta_star &lt;- 0.06\nsigma  &lt;- 0.02\n\n# 解析解の関数定義\nvasicek_yield &lt;- function(rt, x, kappa, theta_star, sigma) {\n  B &lt;- (1 - exp(-kappa * x)) / kappa\n  A &lt;- (theta_star - sigma^2 / (2 * kappa^2)) * (B - x) - (sigma^2 / (4 * kappa)) * B^2\n  yield &lt;- (B * rt - A) / x\n  return(yield)\n}\n\n# 3つの異なる瞬間金利でのカーブを比較\ntenors &lt;- seq(0.1, 30, by = 0.1)\nr0_samples &lt;- c(0.03, 0.06, 0.09)\n\ndf &lt;- list()\nfor(r0 in r0_samples){\n  y &lt;- vasicek_yield(r0, tenors, kappa, theta_star, sigma)\n  df[[length(df) + 1]] &lt;-\n    data.frame(tenor=tenors, yield=y, r_start=as.factor(r0))\n}\ndf &lt;- do.call(rbind, df)\n\n# プロット\nggplot(df) +\n  geom_line(aes(x=tenor, y=yield, linetype=r_start)) +\n  labs(title = \"Yield Curves in Vasicek Model\",\n       x = \"Time to Maturity (Years)\", y = \"Yield\",\n       lty = \"Current Rate (r_t)\")\n\n\n\n\n特定の時点 t におけるイールドカーブ（解析解）\n\n\n\n\n金利のモデルとしての Vasicek モデルには以下のような課題がある。\n\n瞬間金利が負値となる可能性がある\n\nVasicek モデルでは、金利自身の誤差項にウィーナー過程／正規分布を仮定するため、金利 \\(r_t\\) がマイナスになることが許容される。\n\nイールドカーブの形状が限定される\n\nVasicek モデルにおけるイールドカーブの形状は理論上単純な形に限定されており、複雑な凹凸を持つことがある現実のイールドカーブを初期条件として表現できないことがある。\n\nボラティリティが一定である\n\n金利には、現在の金利水準が低いほどボラティリティも小さい傾向があるとされる。しかし、そのような性質は Vasicek モデルでは表現できない。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Vasicekモデル</span>"
    ]
  }
]